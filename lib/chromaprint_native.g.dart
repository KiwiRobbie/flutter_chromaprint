// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Return the version number of Chromaprint.
  ffi.Pointer<ffi.Char> chromaprint_get_version() {
    return _chromaprint_get_version();
  }

  late final _chromaprint_get_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'chromaprint_get_version');
  late final _chromaprint_get_version = _chromaprint_get_versionPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Allocate and initialize the Chromaprint context.
  ///
  /// Note that when Chromaprint is compiled with FFTW, this function is
  /// not reentrant and you need to call it only from one thread at a time.
  /// This is not a problem when using FFmpeg or vDSP.
  ///
  /// @param algorithm the fingerprint algorithm version you want to use, or
  /// CHROMAPRINT_ALGORITHM_DEFAULT for the default algorithm
  ///
  /// @return ctx Chromaprint context pointer
  ffi.Pointer<ChromaprintContext> chromaprint_new(
    int algorithm,
  ) {
    return _chromaprint_new(
      algorithm,
    );
  }

  late final _chromaprint_newPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ChromaprintContext> Function(ffi.Int)>>(
      'chromaprint_new');
  late final _chromaprint_new = _chromaprint_newPtr
      .asFunction<ffi.Pointer<ChromaprintContext> Function(int)>();

  /// Deallocate the Chromaprint context.
  ///
  /// Note that when Chromaprint is compiled with FFTW, this function is
  /// not reentrant and you need to call it only from one thread at a time.
  /// This is not a problem when using FFmpeg or vDSP.
  ///
  /// @param[in] ctx Chromaprint context pointer
  void chromaprint_free(
    ffi.Pointer<ChromaprintContext> ctx,
  ) {
    return _chromaprint_free(
      ctx,
    );
  }

  late final _chromaprint_freePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ChromaprintContext>)>>(
      'chromaprint_free');
  late final _chromaprint_free = _chromaprint_freePtr
      .asFunction<void Function(ffi.Pointer<ChromaprintContext>)>();

  /// Return the fingerprint algorithm this context is configured to use.
  /// @param[in] ctx Chromaprint context pointer
  /// @return current algorithm version
  int chromaprint_get_algorithm(
    ffi.Pointer<ChromaprintContext> ctx,
  ) {
    return _chromaprint_get_algorithm(
      ctx,
    );
  }

  late final _chromaprint_get_algorithmPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ChromaprintContext>)>>(
      'chromaprint_get_algorithm');
  late final _chromaprint_get_algorithm = _chromaprint_get_algorithmPtr
      .asFunction<int Function(ffi.Pointer<ChromaprintContext>)>();

  /// Set a configuration option for the selected fingerprint algorithm.
  ///
  /// DO NOT USE THIS FUNCTION IF YOU ARE PLANNING TO USE
  /// THE GENERATED FINGERPRINTS WITH THE ACOUSTID SERVICE.
  ///
  /// Possible options:
  /// - silence_threshold: threshold for detecting silence, 0-32767
  ///
  /// @param[in] ctx Chromaprint context pointer
  /// @param[in] name option name
  /// @param[in] value option value
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_set_option(
    ffi.Pointer<ChromaprintContext> ctx,
    ffi.Pointer<ffi.Char> name,
    int value,
  ) {
    return _chromaprint_set_option(
      ctx,
      name,
      value,
    );
  }

  late final _chromaprint_set_optionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ChromaprintContext>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('chromaprint_set_option');
  late final _chromaprint_set_option = _chromaprint_set_optionPtr.asFunction<
      int Function(
          ffi.Pointer<ChromaprintContext>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the number of channels that is internally used for fingerprinting.
  ///
  /// @note You normally don't need this. Just set the audio's actual number of channels
  /// when calling chromaprint_start() and everything will work. This is only used for
  /// certain optimized cases to control the audio source.
  ///
  /// @param[in] ctx Chromaprint context pointer
  ///
  /// @return number of channels
  int chromaprint_get_num_channels(
    ffi.Pointer<ChromaprintContext> ctx,
  ) {
    return _chromaprint_get_num_channels(
      ctx,
    );
  }

  late final _chromaprint_get_num_channelsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ChromaprintContext>)>>(
      'chromaprint_get_num_channels');
  late final _chromaprint_get_num_channels = _chromaprint_get_num_channelsPtr
      .asFunction<int Function(ffi.Pointer<ChromaprintContext>)>();

  /// Get the sampling rate that is internally used for fingerprinting.
  ///
  /// @note You normally don't need this. Just set the audio's actual number of channels
  /// when calling chromaprint_start() and everything will work. This is only used for
  /// certain optimized cases to control the audio source.
  ///
  /// @param[in] ctx Chromaprint context pointer
  ///
  /// @return sampling rate
  int chromaprint_get_sample_rate(
    ffi.Pointer<ChromaprintContext> ctx,
  ) {
    return _chromaprint_get_sample_rate(
      ctx,
    );
  }

  late final _chromaprint_get_sample_ratePtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ChromaprintContext>)>>(
      'chromaprint_get_sample_rate');
  late final _chromaprint_get_sample_rate = _chromaprint_get_sample_ratePtr
      .asFunction<int Function(ffi.Pointer<ChromaprintContext>)>();

  /// Get the duration of one item in the raw fingerprint in samples.
  ///
  /// @param[in] ctx Chromaprint context pointer
  ///
  /// @return duration in samples
  int chromaprint_get_item_duration(
    ffi.Pointer<ChromaprintContext> ctx,
  ) {
    return _chromaprint_get_item_duration(
      ctx,
    );
  }

  late final _chromaprint_get_item_durationPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ChromaprintContext>)>>(
      'chromaprint_get_item_duration');
  late final _chromaprint_get_item_duration = _chromaprint_get_item_durationPtr
      .asFunction<int Function(ffi.Pointer<ChromaprintContext>)>();

  /// Get the duration of one item in the raw fingerprint in milliseconds.
  ///
  /// @param[in] ctx Chromaprint context pointer
  ///
  /// @return duration in milliseconds
  int chromaprint_get_item_duration_ms(
    ffi.Pointer<ChromaprintContext> ctx,
  ) {
    return _chromaprint_get_item_duration_ms(
      ctx,
    );
  }

  late final _chromaprint_get_item_duration_msPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ChromaprintContext>)>>(
      'chromaprint_get_item_duration_ms');
  late final _chromaprint_get_item_duration_ms =
      _chromaprint_get_item_duration_msPtr
          .asFunction<int Function(ffi.Pointer<ChromaprintContext>)>();

  /// Get the duration of internal buffers that the fingerprinting algorithm uses.
  ///
  /// @param[in] ctx Chromaprint context pointer
  ///
  /// @return duration in samples
  int chromaprint_get_delay(
    ffi.Pointer<ChromaprintContext> ctx,
  ) {
    return _chromaprint_get_delay(
      ctx,
    );
  }

  late final _chromaprint_get_delayPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ChromaprintContext>)>>(
      'chromaprint_get_delay');
  late final _chromaprint_get_delay = _chromaprint_get_delayPtr
      .asFunction<int Function(ffi.Pointer<ChromaprintContext>)>();

  /// Get the duration of internal buffers that the fingerprinting algorithm uses.
  ///
  /// @param[in] ctx Chromaprint context pointer
  ///
  /// @return duration in milliseconds
  int chromaprint_get_delay_ms(
    ffi.Pointer<ChromaprintContext> ctx,
  ) {
    return _chromaprint_get_delay_ms(
      ctx,
    );
  }

  late final _chromaprint_get_delay_msPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ChromaprintContext>)>>(
      'chromaprint_get_delay_ms');
  late final _chromaprint_get_delay_ms = _chromaprint_get_delay_msPtr
      .asFunction<int Function(ffi.Pointer<ChromaprintContext>)>();

  /// Restart the computation of a fingerprint with a new audio stream.
  ///
  /// @param[in] ctx Chromaprint context pointer
  /// @param[in] sample_rate sample rate of the audio stream (in Hz)
  /// @param[in] num_channels numbers of channels in the audio stream (1 or 2)
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_start(
    ffi.Pointer<ChromaprintContext> ctx,
    int sample_rate,
    int num_channels,
  ) {
    return _chromaprint_start(
      ctx,
      sample_rate,
      num_channels,
    );
  }

  late final _chromaprint_startPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ChromaprintContext>, ffi.Int,
              ffi.Int)>>('chromaprint_start');
  late final _chromaprint_start = _chromaprint_startPtr
      .asFunction<int Function(ffi.Pointer<ChromaprintContext>, int, int)>();

  /// Send audio data to the fingerprint calculator.
  ///
  /// @param[in] ctx Chromaprint context pointer
  /// @param[in] data raw audio data, should point to an array of 16-bit signed
  /// integers in native byte-order
  /// @param[in] size size of the data buffer (in samples)
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_feed(
    ffi.Pointer<ChromaprintContext> ctx,
    ffi.Pointer<ffi.Int16> data,
    int size,
  ) {
    return _chromaprint_feed(
      ctx,
      data,
      size,
    );
  }

  late final _chromaprint_feedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ChromaprintContext>,
              ffi.Pointer<ffi.Int16>, ffi.Int)>>('chromaprint_feed');
  late final _chromaprint_feed = _chromaprint_feedPtr.asFunction<
      int Function(
          ffi.Pointer<ChromaprintContext>, ffi.Pointer<ffi.Int16>, int)>();

  /// Process any remaining buffered audio data.
  ///
  /// @param[in] ctx Chromaprint context pointer
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_finish(
    ffi.Pointer<ChromaprintContext> ctx,
  ) {
    return _chromaprint_finish(
      ctx,
    );
  }

  late final _chromaprint_finishPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ChromaprintContext>)>>(
      'chromaprint_finish');
  late final _chromaprint_finish = _chromaprint_finishPtr
      .asFunction<int Function(ffi.Pointer<ChromaprintContext>)>();

  /// Return the calculated fingerprint as a compressed string.
  ///
  /// The caller is responsible for freeing the returned pointer using
  /// chromaprint_dealloc().
  ///
  /// @param[in] ctx Chromaprint context pointer
  /// @param[out] fingerprint pointer to a pointer, where a pointer to the allocated array
  /// will be stored
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_get_fingerprint(
    ffi.Pointer<ChromaprintContext> ctx,
    ffi.Pointer<ffi.Pointer<ffi.Char>> fingerprint,
  ) {
    return _chromaprint_get_fingerprint(
      ctx,
      fingerprint,
    );
  }

  late final _chromaprint_get_fingerprintPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ChromaprintContext>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'chromaprint_get_fingerprint');
  late final _chromaprint_get_fingerprint =
      _chromaprint_get_fingerprintPtr.asFunction<
          int Function(ffi.Pointer<ChromaprintContext>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Return the calculated fingerprint as an array of 32-bit integers.
  ///
  /// The caller is responsible for freeing the returned pointer using
  /// chromaprint_dealloc().
  ///
  /// @param[in] ctx Chromaprint context pointer
  /// @param[out] fingerprint pointer to a pointer, where a pointer to the allocated array
  /// will be stored
  /// @param[out] size number of items in the returned raw fingerprint
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_get_raw_fingerprint(
    ffi.Pointer<ChromaprintContext> ctx,
    ffi.Pointer<ffi.Pointer<ffi.Uint32>> fingerprint,
    ffi.Pointer<ffi.Int> size,
  ) {
    return _chromaprint_get_raw_fingerprint(
      ctx,
      fingerprint,
      size,
    );
  }

  late final _chromaprint_get_raw_fingerprintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ChromaprintContext>,
              ffi.Pointer<ffi.Pointer<ffi.Uint32>>,
              ffi.Pointer<ffi.Int>)>>('chromaprint_get_raw_fingerprint');
  late final _chromaprint_get_raw_fingerprint =
      _chromaprint_get_raw_fingerprintPtr.asFunction<
          int Function(ffi.Pointer<ChromaprintContext>,
              ffi.Pointer<ffi.Pointer<ffi.Uint32>>, ffi.Pointer<ffi.Int>)>();

  /// Return the length of the current raw fingerprint.
  ///
  /// @param[in] ctx Chromaprint context pointer
  /// @param[out] size number of items in the current raw fingerprint
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_get_raw_fingerprint_size(
    ffi.Pointer<ChromaprintContext> ctx,
    ffi.Pointer<ffi.Int> size,
  ) {
    return _chromaprint_get_raw_fingerprint_size(
      ctx,
      size,
    );
  }

  late final _chromaprint_get_raw_fingerprint_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ChromaprintContext>,
              ffi.Pointer<ffi.Int>)>>('chromaprint_get_raw_fingerprint_size');
  late final _chromaprint_get_raw_fingerprint_size =
      _chromaprint_get_raw_fingerprint_sizePtr.asFunction<
          int Function(
              ffi.Pointer<ChromaprintContext>, ffi.Pointer<ffi.Int>)>();

  /// Return 32-bit hash of the calculated fingerprint.
  ///
  /// See chromaprint_hash_fingerprint() for details on how to use the hash.
  ///
  /// @param[in] ctx Chromaprint context pointer
  /// @param[out] hash pointer to a 32-bit integer where the hash will be stored
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_get_fingerprint_hash(
    ffi.Pointer<ChromaprintContext> ctx,
    ffi.Pointer<ffi.Uint32> hash,
  ) {
    return _chromaprint_get_fingerprint_hash(
      ctx,
      hash,
    );
  }

  late final _chromaprint_get_fingerprint_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ChromaprintContext>,
              ffi.Pointer<ffi.Uint32>)>>('chromaprint_get_fingerprint_hash');
  late final _chromaprint_get_fingerprint_hash =
      _chromaprint_get_fingerprint_hashPtr.asFunction<
          int Function(
              ffi.Pointer<ChromaprintContext>, ffi.Pointer<ffi.Uint32>)>();

  /// Clear the current fingerprint, but allow more data to be processed.
  ///
  /// This is useful if you are processing a long stream and want to many
  /// smaller fingerprints, instead of waiting for the entire stream to be
  /// processed.
  ///
  /// @param[in] ctx Chromaprint context pointer
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_clear_fingerprint(
    ffi.Pointer<ChromaprintContext> ctx,
  ) {
    return _chromaprint_clear_fingerprint(
      ctx,
    );
  }

  late final _chromaprint_clear_fingerprintPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ChromaprintContext>)>>(
      'chromaprint_clear_fingerprint');
  late final _chromaprint_clear_fingerprint = _chromaprint_clear_fingerprintPtr
      .asFunction<int Function(ffi.Pointer<ChromaprintContext>)>();

  /// Compress and optionally base64-encode a raw fingerprint
  ///
  /// The caller is responsible for freeing the returned pointer using
  /// chromaprint_dealloc().
  ///
  /// @param[in] fp pointer to an array of 32-bit integers representing the raw
  /// fingerprint to be encoded
  /// @param[in] size number of items in the raw fingerprint
  /// @param[in] algorithm Chromaprint algorithm version which was used to generate the
  /// raw fingerprint
  /// @param[out] encoded_fp pointer to a pointer, where the encoded fingerprint will be
  /// stored
  /// @param[out] encoded_size size of the encoded fingerprint in bytes
  /// @param[in] base64 Whether to return binary data or base64-encoded ASCII data. The
  /// compressed fingerprint will be encoded using base64 with the
  /// URL-safe scheme if you set this parameter to 1. It will return
  /// binary data if it's 0.
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_encode_fingerprint(
    ffi.Pointer<ffi.Uint32> fp,
    int size,
    int algorithm,
    ffi.Pointer<ffi.Pointer<ffi.Char>> encoded_fp,
    ffi.Pointer<ffi.Int> encoded_size,
    int base64,
  ) {
    return _chromaprint_encode_fingerprint(
      fp,
      size,
      algorithm,
      encoded_fp,
      encoded_size,
      base64,
    );
  }

  late final _chromaprint_encode_fingerprintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Uint32>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Int>,
              ffi.Int)>>('chromaprint_encode_fingerprint');
  late final _chromaprint_encode_fingerprint =
      _chromaprint_encode_fingerprintPtr.asFunction<
          int Function(ffi.Pointer<ffi.Uint32>, int, int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Int>, int)>();

  /// Uncompress and optionally base64-decode an encoded fingerprint
  ///
  /// The caller is responsible for freeing the returned pointer using
  /// chromaprint_dealloc().
  ///
  /// @param[in] encoded_fp pointer to an encoded fingerprint
  /// @param[in] encoded_size size of the encoded fingerprint in bytes
  /// @param[out] fp pointer to a pointer, where the decoded raw fingerprint (array
  /// of 32-bit integers) will be stored
  /// @param[out] size Number of items in the returned raw fingerprint
  /// @param[out] algorithm Chromaprint algorithm version which was used to generate the
  /// raw fingerprint
  /// @param[in] base64 Whether the encoded_fp parameter contains binary data or
  /// base64-encoded ASCII data. If 1, it will base64-decode the data
  /// before uncompressing the fingerprint.
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_decode_fingerprint(
    ffi.Pointer<ffi.Char> encoded_fp,
    int encoded_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint32>> fp,
    ffi.Pointer<ffi.Int> size,
    ffi.Pointer<ffi.Int> algorithm,
    int base64,
  ) {
    return _chromaprint_decode_fingerprint(
      encoded_fp,
      encoded_size,
      fp,
      size,
      algorithm,
      base64,
    );
  }

  late final _chromaprint_decode_fingerprintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Uint32>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Int)>>('chromaprint_decode_fingerprint');
  late final _chromaprint_decode_fingerprint =
      _chromaprint_decode_fingerprintPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Pointer<ffi.Uint32>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              int)>();

  /// Generate a single 32-bit hash for a raw fingerprint.
  ///
  /// If two fingerprints are similar, their hashes generated by this function
  /// will also be similar. If they are significantly different, their hashes
  /// will most likely be significantly different as well, but you can't rely
  /// on that.
  ///
  /// You compare two hashes by counting the bits in which they differ. Normally
  /// that would be something like POPCNT(hash1 XOR hash2), which returns a
  /// number between 0 and 32. Anthing above 15 means the hashes are
  /// completely different.
  ///
  /// @param[in] fp pointer to an array of 32-bit integers representing the raw
  /// fingerprint to be hashed
  /// @param[in] size number of items in the raw fingerprint
  /// @param[out] hash pointer to a 32-bit integer where the hash will be stored
  ///
  /// @return 0 on error, 1 on success
  int chromaprint_hash_fingerprint(
    ffi.Pointer<ffi.Uint32> fp,
    int size,
    ffi.Pointer<ffi.Uint32> hash,
  ) {
    return _chromaprint_hash_fingerprint(
      fp,
      size,
      hash,
    );
  }

  late final _chromaprint_hash_fingerprintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Uint32>, ffi.Int,
              ffi.Pointer<ffi.Uint32>)>>('chromaprint_hash_fingerprint');
  late final _chromaprint_hash_fingerprint =
      _chromaprint_hash_fingerprintPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Uint32>, int, ffi.Pointer<ffi.Uint32>)>();

  /// Free memory allocated by any function from the Chromaprint API.
  ///
  /// @param ptr pointer to be deallocated
  void chromaprint_dealloc(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _chromaprint_dealloc(
      ptr,
    );
  }

  late final _chromaprint_deallocPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'chromaprint_dealloc');
  late final _chromaprint_dealloc = _chromaprint_deallocPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();
}

final class __fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> __val;
}

final class ChromaprintContextPrivate extends ffi.Opaque {}

final class ChromaprintMatcherContextPrivate extends ffi.Opaque {}

abstract class ChromaprintAlgorithm {
  static const int CHROMAPRINT_ALGORITHM_TEST1 = 0;
  static const int CHROMAPRINT_ALGORITHM_TEST2 = 1;
  static const int CHROMAPRINT_ALGORITHM_TEST3 = 2;
  static const int CHROMAPRINT_ALGORITHM_TEST4 = 3;
  static const int CHROMAPRINT_ALGORITHM_TEST5 = 4;
  static const int CHROMAPRINT_ALGORITHM_DEFAULT = 1;
}

typedef ChromaprintContext = ChromaprintContextPrivate;

const int _STDINT_H = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __TIMESIZE = 64;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int __GLIBC_USE_C2X_STRTOL = 1;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_60559_BFP__ = 201404;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_IEC_60559_COMPLEX__ = 201404;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 38;

const int _SYS_CDEFS_H = 1;

const int __THROW = 1;

const int __THROWNL = 1;

const int __glibc_c99_flexarr_available = 1;

const int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = 0;

const int __HAVE_GENERIC_SELECTION = 0;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int _BITS_TYPES_H = 1;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int _BITS_WCHAR_H = 1;

const int __WCHAR_MAX = 2147483647;

const int __WCHAR_MIN = -2147483648;

const int _BITS_STDINT_INTN_H = 1;

const int _BITS_STDINT_UINTN_H = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const int CHROMAPRINT_VERSION_MAJOR = 1;

const int CHROMAPRINT_VERSION_MINOR = 4;

const int CHROMAPRINT_VERSION_PATCH = 4;
